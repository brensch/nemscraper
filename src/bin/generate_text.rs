use clap::Parser;
use std::fs;
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

#[derive(Parser)]
#[command(name = "dir-to-context")]
#[command(about = "Convert directory contents to LLM-friendly context file")]
struct Args {
    /// Input directory to process
    input_dir: PathBuf,

    /// Output file to write context to
    output_file: PathBuf,

    /// Maximum file size in bytes to include (default: 1MB)
    #[arg(long, default_value = "1048576")]
    max_file_size: u64,

    /// Include hidden files and directories
    #[arg(long)]
    include_hidden: bool,

    /// File extensions to include (comma-separated, e.g., "rs,py,js")
    #[arg(long)]
    extensions: Option<String>,

    /// Directories to exclude (comma-separated, e.g., "target,.git,node_modules")
    #[arg(long, default_value = "target,.git,node_modules,.vscode,dist,build")]
    exclude_dirs: String,
}

fn main() -> io::Result<()> {
    let args = Args::parse();

    if !args.input_dir.exists() {
        eprintln!(
            "Error: Input directory '{}' does not exist",
            args.input_dir.display()
        );
        std::process::exit(1);
    }

    if !args.input_dir.is_dir() {
        eprintln!("Error: '{}' is not a directory", args.input_dir.display());
        std::process::exit(1);
    }

    let exclude_dirs: Vec<&str> = args.exclude_dirs.split(',').collect();
    let allowed_extensions: Option<Vec<String>> = args
        .extensions
        .as_ref()
        .map(|ext| ext.split(',').map(|s| s.trim().to_lowercase()).collect());

    let mut output_file = fs::File::create(&args.output_file)?;

    // Write header
    writeln!(
        output_file,
        "# Directory Context: {}",
        args.input_dir.display()
    )?;
    writeln!(output_file, "# Generated by dir-to-context tool")?;
    writeln!(output_file, "# Total files processed below\n")?;

    let mut file_count = 0;
    let mut total_size = 0u64;

    // Walk directory
    for entry in WalkDir::new(&args.input_dir)
        .follow_links(false)
        .into_iter()
        .filter_entry(|e| {
            if !args.include_hidden && is_hidden(e.path()) {
                return false;
            }

            if e.path().is_dir() {
                let dir_name = e.path().file_name().and_then(|n| n.to_str()).unwrap_or("");
                return !exclude_dirs.contains(&dir_name);
            }

            true
        })
    {
        let entry = match entry {
            Ok(entry) => entry,
            Err(e) => {
                eprintln!("Warning: {}", e);
                continue;
            }
        };

        let path = entry.path();

        // Skip directories
        if path.is_dir() {
            continue;
        }

        // Check file extension if specified
        if let Some(ref extensions) = allowed_extensions {
            if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
                if !extensions.contains(&ext.to_lowercase()) {
                    continue;
                }
            } else {
                continue; // No extension, skip if extensions filter is active
            }
        }

        // Check file size
        let metadata = match fs::metadata(path) {
            Ok(metadata) => metadata,
            Err(e) => {
                eprintln!(
                    "Warning: Cannot read metadata for {}: {}",
                    path.display(),
                    e
                );
                continue;
            }
        };

        if metadata.len() > args.max_file_size {
            writeln!(
                output_file,
                "\n## {}",
                get_relative_path(&args.input_dir, path)
            )?;
            writeln!(output_file, "```")?;
            writeln!(
                output_file,
                "[File too large: {} bytes, skipped]",
                metadata.len()
            )?;
            writeln!(output_file, "```\n")?;
            continue;
        }

        // Read and write file content
        match read_file_content(path) {
            Ok(content) => {
                if is_likely_binary(&content) {
                    writeln!(
                        output_file,
                        "\n## {}",
                        get_relative_path(&args.input_dir, path)
                    )?;
                    writeln!(output_file, "```")?;
                    writeln!(output_file, "[Binary file, skipped]")?;
                    writeln!(output_file, "```\n")?;
                } else {
                    writeln!(
                        output_file,
                        "\n## {}",
                        get_relative_path(&args.input_dir, path)
                    )?;
                    writeln!(output_file, "```")?;
                    write!(output_file, "{}", content)?;
                    if !content.ends_with('\n') {
                        writeln!(output_file)?;
                    }
                    writeln!(output_file, "```\n")?;

                    file_count += 1;
                    total_size += metadata.len();
                }
            }
            Err(e) => {
                eprintln!("Warning: Cannot read {}: {}", path.display(), e);
                writeln!(
                    output_file,
                    "\n## {}",
                    get_relative_path(&args.input_dir, path)
                )?;
                writeln!(output_file, "```")?;
                writeln!(output_file, "[Error reading file: {}]", e)?;
                writeln!(output_file, "```\n")?;
            }
        }
    }

    // Write summary at the end
    writeln!(output_file, "\n---")?;
    writeln!(output_file, "# Summary")?;
    writeln!(output_file, "- Total files processed: {}", file_count)?;
    writeln!(output_file, "- Total content size: {} bytes", total_size)?;
    writeln!(
        output_file,
        "- Source directory: {}",
        args.input_dir.display()
    )?;

    println!(
        "Successfully processed {} files from '{}' to '{}'",
        file_count,
        args.input_dir.display(),
        args.output_file.display()
    );
    println!("Total content size: {} bytes", total_size);

    Ok(())
}

fn get_relative_path(base: &Path, target: &Path) -> String {
    target
        .strip_prefix(base)
        .unwrap_or(target)
        .to_string_lossy()
        .replace('\\', "/") // Normalize path separators
}

fn is_hidden(path: &Path) -> bool {
    path.file_name()
        .and_then(|name| name.to_str())
        .map(|name| name.starts_with('.'))
        .unwrap_or(false)
}

fn read_file_content(path: &Path) -> io::Result<String> {
    let bytes = fs::read(path)?;

    // Try to decode as UTF-8 first
    match String::from_utf8(bytes.clone()) {
        Ok(content) => Ok(content),
        Err(_) => {
            // Try to detect encoding and convert
            let (content, _, _) = encoding_rs::UTF_8.decode(&bytes);
            Ok(content.into_owned())
        }
    }
}

fn is_likely_binary(content: &str) -> bool {
    // Simple heuristic: if more than 1% of characters are null bytes or
    // non-printable control characters (except common whitespace), it's likely binary
    let total_chars = content.len();
    if total_chars == 0 {
        return false;
    }

    let suspicious_chars = content
        .chars()
        .filter(|&c| c == '\0' || (c.is_control() && c != '\n' && c != '\r' && c != '\t'))
        .count();

    suspicious_chars as f64 / total_chars as f64 > 0.01
}
